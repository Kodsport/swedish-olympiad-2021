# Bikupor

Vi börjar med att lösa ett enklare fall, nämligen när vi inte tar någon av de K sista noderna (låt oss kalla dem "tunga" noder och de N-K första för "lätta" noder). Då kommer Ljungström att ta de K tunga noderna och vi vill helt enkelt hitta en delmängd lätta noder som inte har några tunga noder som grannar. Här finns det ingen mening med att ta mer än en nod: om vi har en lösning som innehåller fler noder så är det också en giltig lösning att ta bara en av dem. Så vi loopar igenom alla lätta noder, och för var och en loopar vi igenom dess grannar och kollar om någon av dessa är tung. Om ingen är det så har vi hittat en lösning. 

Om man bara implementerar fallet ovan och skriver ut "-1" ifall ingen lösning hittades, så får man 12 poäng. Det beror på att när K = 1 så räcker det med att kolla lätta noder. Men i de andra fallen så kan lösningen innehålla tunga noder. Här är en strategi som ger ganska mycket delpoäng: Testa att lägga en tung nod A till vår lösning. En sak som händer då är att Ljungström inte kan ta noden A och kommer istället ta nod N-K (låt oss säga att nod N-K blir en tung nod då). Vi kan nu kolla alla A:s grannar och ifall ingen av dem är tunga så har vi en lösning. Annars så måste vi ta med de tunga grannarna i vår lösning. Därefter blir flera noder tunga, och vi fortsätter kolla på grannarnas grannar osv. Notera att vi lägger till noden A, och därefter lägger vi bara till noder som vi måste lägga till ifall A finns i en lösning. Så om vi kör den här proceduren för var och en av de K sista noderna så kommer den garanterat hitta en lösning om det finns någon. Det enklaste sättet att implementera det på är nog att göra något som liknar Prims algoritm och använda prioritetsköer. Då blir det O(K(N+M)logM) men det går även att få bort log-faktorn. Den här typen av lösning ger upp till 65 poäng.

Fullpoängslösningen ser lite annorlunda ut. Låt oss säga att vi letar efter en lösning där vi tar X av de K+X sista noderna, och Ljungström tar resterande K. Vi kan anta att vår delmängd är sammanhängade, för om den bestod av flera sammanhängade komponenter skulle vi kunna ta en av dem och få en giltig lösning. Dessutom vill vi ju inte att Ljungströms noder ska vara grannar med någon av våra. Det vi vill göra är alltså att kolla på grafen som bildas genom att bara ta de K+X sista noderna, och hitta en sammanhängande komponent av storlek exakt X (< X funkar också). För att få lösningen tillräckligt snabb behöver vi göra det i nästan konstant tid för varje X. Om vi låter X börja från 1 och öka så får vi att en nod (N-K-X+1) läggs till i varje steg. Vissa komponenter kommer då att mergas ihop, och de växer då i storlek. Vi behöver något effektivt sätt att slå ihop komponenter, kolla om två noder är i samma komponent, och hålla koll på komponenternas storlek. Det här är ett jobb för den fantastiska datastrukturen [Union-Find](https://cp-algorithms.com/data_structures/disjoint_set_union.html), som kan göra dessa operationer i nästan konstant tid! Det enda som återstår är då att snabbt kunna kolla om minsta komponentstorleken är <= X, vilket kan göras genom att ha komponentstorlekarna i någon lämplig datastruktur (t.ex. set i C++). Komplexiteten blir O(NlogN + M).

Värt att notera är att det antagligen går att klara sig utan union-find med fullpoängslösningen, tack vare problemets struktur. Eftersom vi bryter lösningen om den minsta komponenten är <= X får vi begränsningar på hur små komponenterna kan vara efter ett visst antal steg. Efter X=sqrt(N) kommer alla komponenter ha minst sqrt(N) noder, och det finns därför högst sqrt(N) komponenter då. Det här innebär att varje nod kommer delta i högst 2sqrt(N) merge-operationer (en för varje X < sqrt(N) och en för varje annan komponent efter X >= sqrt(N)). Så om vi mergar ihop komponenter genom att söka igenom noder och markera dem (med DFS eller BFS), går det att få ihop en O(Nsqrt(N))-lösning som antagligen är tillräckligt snabb.

